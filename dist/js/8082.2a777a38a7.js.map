{"version":3,"sources":["webpack://react-custmoer-webpack/./node_modules/mobx-react-lite/es/utils/createTimerBasedReactionCleanupTracking.js"],"names":["createTimerBasedReactionCleanupTracking","reactionCleanupHandle","uncommittedReactionRefs","Set","ensureCleanupTimerRunning","undefined","setTimeout","cleanUncommittedReactions","now","Date","forEach","ref","tracking","current","cleanAt","reaction","dispose","delete","size","addReactionToTrack","reactionTrackingRef","objectRetainedByReact","add","recordReactionAsCommitted","reactionRef","forceCleanupTimerToRunNowForTests","clearTimeout","resetCleanupScheduleForTests","e_1","_a","uncommittedReactionRefs_1","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__values","uncommittedReactionRefs_1_1","e_1_1","error","return","clear"],"mappings":"+JAeO,SAASA,IAIZ,IAIIC,EAJAC,EAA0B,IAAIC,IA6ClC,SAASC,SACyBC,IAA1BJ,IACAA,EAAwBK,WAAWC,EAA2B,OAatE,SAASA,IACLN,OAAwBI,EAGxB,IAAIG,EAAMC,KAAKD,MACfN,EAAwBQ,SAAQ,SAAUC,GACtC,IAAIC,EAAWD,EAAIE,QACfD,GACIJ,GAAOI,EAASE,UAEhBF,EAASG,SAASC,UAClBL,EAAIE,QAAU,KACdX,EAAwBe,OAAON,OAIvCT,EAAwBgB,KAAO,GAG/Bd,IAGR,MAAO,CACHe,mBAAoB,SAAUC,EAAqBL,EAKnDM,GAtCJ,IAA2CV,EAyCnC,OAFAS,EAAoBP,SAAU,QAAmBE,GAvCdJ,EAwCDS,EAvCtClB,EAAwBoB,IAAIX,GAC5BP,IAuCWgB,EAAoBP,SAE/BU,0BAvCJ,SAAmCC,GAC/BtB,EAAwBe,OAAOO,IAuC/BC,kCArFJ,WAGQxB,IACAyB,aAAazB,GACbM,MAiFJoB,6BA7EJ,WACI,IAAIC,EAAKC,EACT,GAAI3B,EAAwBgB,KAAO,EAAG,CAClC,IACI,IAAK,IAAIY,EAzCiB,SAASC,GAC/C,IAAIC,EAAsB,mBAAXC,QAAyBA,OAAOC,SAAUC,EAAIH,GAAKD,EAAEC,GAAII,EAAI,EAC5E,GAAID,EAAG,OAAOA,EAAEE,KAAKN,GACrB,GAAIA,GAAyB,iBAAbA,EAAEO,OAAqB,MAAO,CAC1CC,KAAM,WAEF,OADIR,GAAKK,GAAKL,EAAEO,SAAQP,OAAI,GACrB,CAAES,MAAOT,GAAKA,EAAEK,KAAMK,MAAOV,KAG5C,MAAM,IAAIW,UAAUV,EAAI,0BAA4B,mCAgCHW,CAASzC,GAA0B0C,EAA8Bd,EAA0BS,QAASK,EAA4BH,KAAMG,EAA8Bd,EAA0BS,OAAQ,CACvO,IAAI5B,EAAMiC,EAA4BJ,MAClC5B,EAAWD,EAAIE,QACfD,IACAA,EAASG,SAASC,UAClBL,EAAIE,QAAU,OAI1B,MAAOgC,GAASjB,EAAM,CAAEkB,MAAOD,GAC/B,QACI,IACQD,IAAgCA,EAA4BH,OAASZ,EAAKC,EAA0BiB,SAASlB,EAAGQ,KAAKP,GAE7H,QAAU,GAAIF,EAAK,MAAMA,EAAIkB,OAEjC5C,EAAwB8C,QAExB/C,IACAyB,aAAazB,GACbA,OAAwBI","file":"js/8082.2a777a38a7.js","sourcesContent":["var __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { CLEANUP_TIMER_LOOP_MILLIS, createTrackingData } from \"./reactionCleanupTrackingCommon\";\n/**\n * timers, gc-style, uncommitted reaction cleanup\n */\nexport function createTimerBasedReactionCleanupTracking() {\n    /**\n     * Reactions created by components that have yet to be fully mounted.\n     */\n    var uncommittedReactionRefs = new Set();\n    /**\n     * Latest 'uncommitted reactions' cleanup timer handle.\n     */\n    var reactionCleanupHandle;\n    /* istanbul ignore next */\n    /**\n     * Only to be used by test functions; do not export outside of mobx-react-lite\n     */\n    function forceCleanupTimerToRunNowForTests() {\n        // This allows us to control the execution of the cleanup timer\n        // to force it to run at awkward times in unit tests.\n        if (reactionCleanupHandle) {\n            clearTimeout(reactionCleanupHandle);\n            cleanUncommittedReactions();\n        }\n    }\n    /* istanbul ignore next */\n    function resetCleanupScheduleForTests() {\n        var e_1, _a;\n        if (uncommittedReactionRefs.size > 0) {\n            try {\n                for (var uncommittedReactionRefs_1 = __values(uncommittedReactionRefs), uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next(); !uncommittedReactionRefs_1_1.done; uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next()) {\n                    var ref = uncommittedReactionRefs_1_1.value;\n                    var tracking = ref.current;\n                    if (tracking) {\n                        tracking.reaction.dispose();\n                        ref.current = null;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (uncommittedReactionRefs_1_1 && !uncommittedReactionRefs_1_1.done && (_a = uncommittedReactionRefs_1.return)) _a.call(uncommittedReactionRefs_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            uncommittedReactionRefs.clear();\n        }\n        if (reactionCleanupHandle) {\n            clearTimeout(reactionCleanupHandle);\n            reactionCleanupHandle = undefined;\n        }\n    }\n    function ensureCleanupTimerRunning() {\n        if (reactionCleanupHandle === undefined) {\n            reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);\n        }\n    }\n    function scheduleCleanupOfReactionIfLeaked(ref) {\n        uncommittedReactionRefs.add(ref);\n        ensureCleanupTimerRunning();\n    }\n    function recordReactionAsCommitted(reactionRef) {\n        uncommittedReactionRefs.delete(reactionRef);\n    }\n    /**\n     * Run by the cleanup timer to dispose any outstanding reactions\n     */\n    function cleanUncommittedReactions() {\n        reactionCleanupHandle = undefined;\n        // Loop through all the candidate leaked reactions; those older\n        // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n        var now = Date.now();\n        uncommittedReactionRefs.forEach(function (ref) {\n            var tracking = ref.current;\n            if (tracking) {\n                if (now >= tracking.cleanAt) {\n                    // It's time to tidy up this leaked reaction.\n                    tracking.reaction.dispose();\n                    ref.current = null;\n                    uncommittedReactionRefs.delete(ref);\n                }\n            }\n        });\n        if (uncommittedReactionRefs.size > 0) {\n            // We've just finished a round of cleanups but there are still\n            // some leak candidates outstanding.\n            ensureCleanupTimerRunning();\n        }\n    }\n    return {\n        addReactionToTrack: function (reactionTrackingRef, reaction, \n        /**\n         * On timer based implementation we don't really need this object,\n         * but we keep the same api\n         */\n        objectRetainedByReact) {\n            reactionTrackingRef.current = createTrackingData(reaction);\n            scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n            return reactionTrackingRef.current;\n        },\n        recordReactionAsCommitted: recordReactionAsCommitted,\n        forceCleanupTimerToRunNowForTests: forceCleanupTimerToRunNowForTests,\n        resetCleanupScheduleForTests: resetCleanupScheduleForTests\n    };\n}\n//# sourceMappingURL=createTimerBasedReactionCleanupTracking.js.map"],"sourceRoot":""}