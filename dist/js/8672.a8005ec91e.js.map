{"version":3,"sources":["webpack://react-custmoer-webpack/./node_modules/mobx-react-lite/es/useObserver.js"],"names":["observerComponentNameFor","baseComponentName","ObjectToBeRetainedByReact","useObserver","fn","objectRetainedByReact","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__read","forceUpdate","reactionTrackingRef","current","newReaction","trackingData_1","mounted","changedBeforeMount","rendering","exception","reaction","cleanAt","Infinity","dispose","track"],"mappings":"iNAsBA,SAASA,EAAyBC,GAC9B,MAAO,WAAaA,EAKxB,IAAIC,EACA,aAIG,SAASC,EAAYC,EAAIH,GAE5B,QAD0B,IAAtBA,IAAgCA,EAAoB,aACpD,SACA,OAAOG,IAEX,IAAqEC,EAtCnC,SAAUC,EAAGC,GAC/C,IAAIC,EAAsB,mBAAXC,QAAyBH,EAAEG,OAAOC,UACjD,IAAKF,EAAG,OAAOF,EACf,IAAmBK,EAAYC,EAA3BC,EAAIL,EAAEM,KAAKR,GAAOS,EAAK,GAC3B,IACI,WAAc,IAANR,GAAgBA,KAAM,MAAQI,EAAIE,EAAEG,QAAQC,MAAMF,EAAGG,KAAKP,EAAEQ,OAExE,MAAOC,GAASR,EAAI,CAAEQ,MAAOA,GAC7B,QACI,IACQT,IAAMA,EAAEM,OAAST,EAAIK,EAAU,SAAIL,EAAEM,KAAKD,GAElD,QAAU,GAAID,EAAG,MAAMA,EAAEQ,OAE7B,OAAOL,EAwBEM,CAAO,WAAe,IAAInB,GAA8B,GAA+B,GAC5FoB,GAAc,SAIdC,EAAsB,SAAa,MACvC,IAAKA,EAAoBC,QAGrB,IAAIC,EAAc,IAAI,KAASzB,EAAyBC,IAAoB,WAMpEyB,EAAeC,QAEfL,IAKAI,EAAeE,oBAAqB,KAGxCF,GAAiB,QAAmBH,EAAqBE,EAAapB,GAE9E,IAyCIwB,EACAC,EA1CAC,EAAWR,EAAoBC,QAAQO,SAmD3C,GAlDA,gBAAoBA,EAAU,KAC9B,aAAgB,WA+BZ,OA7BA,QAA0BR,GACtBA,EAAoBC,SAIpBD,EAAoBC,QAAQG,SAAU,EAElCJ,EAAoBC,QAAQI,qBAC5BL,EAAoBC,QAAQI,oBAAqB,EACjDN,OASJC,EAAoBC,QAAU,CAC1BO,SAAU,IAAI,KAAS/B,EAAyBC,IAAoB,WAEhEqB,OAEJK,SAAS,EACTC,oBAAoB,EACpBI,QAASC,KAEbX,KAEG,WACHC,EAAoBC,QAAQO,SAASG,UACrCX,EAAoBC,QAAU,QAEnC,IAMHO,EAASI,OAAM,WACX,IACIN,EAAYzB,IAEhB,MAAOQ,GACHkB,EAAYlB,MAGhBkB,EACA,MAAMA,EAEV,OAAOD","file":"js/8672.a8005ec91e.js","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { addReactionToTrack, recordReactionAsCommitted } from \"./utils/reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useForceUpdate } from \"./utils/utils\";\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\" + baseComponentName;\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nvar ObjectToBeRetainedByReact = /** @class */ (function () {\n    function ObjectToBeRetainedByReact() {\n    }\n    return ObjectToBeRetainedByReact;\n}());\nexport function useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var _a = __read(React.useState(new ObjectToBeRetainedByReact()), 1), objectRetainedByReact = _a[0];\n    var forceUpdate = useForceUpdate();\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var reactionTrackingRef = React.useRef(null);\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n        var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData_1.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.\n                trackingData_1.changedBeforeMount = true;\n            }\n        });\n        var trackingData_1 = addReactionToTrack(reactionTrackingRef, newReaction, objectRetainedByReact);\n    }\n    var reaction = reactionTrackingRef.current.reaction;\n    React.useDebugValue(reaction, printDebugValue);\n    React.useEffect(function () {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef);\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true;\n            // Got a change before first mount, force an update\n            if (reactionTrackingRef.current.changedBeforeMount) {\n                reactionTrackingRef.current.changedBeforeMount = false;\n                forceUpdate();\n            }\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This can be due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n                    // We've definitely already been mounted at this point\n                    forceUpdate();\n                }),\n                mounted: true,\n                changedBeforeMount: false,\n                cleanAt: Infinity\n            };\n            forceUpdate();\n        }\n        return function () {\n            reactionTrackingRef.current.reaction.dispose();\n            reactionTrackingRef.current = null;\n        };\n    }, []);\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    var rendering;\n    var exception;\n    reaction.track(function () {\n        try {\n            rendering = fn();\n        }\n        catch (e) {\n            exception = e;\n        }\n    });\n    if (exception) {\n        throw exception; // re-throw any exceptions caught during rendering\n    }\n    return rendering;\n}\n//# sourceMappingURL=useObserver.js.map"],"sourceRoot":""}